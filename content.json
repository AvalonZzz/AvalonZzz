{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/10/31/hello-world/"},{"title":"缓存机制","text":"缓存分类浏览器缓存大致上分为四类，按以下优先级顺序排列： Memery Cache Service Worker Cache HTTP Cache Push Cache HTTP CacheHTTP Cache 分为强缓存和协商缓存，强缓存优先级高，只有在强缓存未命中的情况下才会走协商缓存。 强缓存强缓存通过 expires 和 cache-control 字段来控制，如果强缓存命中则直接从缓存中取数据，不再发起服务器请求。强缓存命中的 HTTP 状态码是 200，如下图： 强缓存以前使用 expires 字段来控制，这是一个时间戳，通过比对本地时间来判断资源是否过期，极度依赖本地时间的准确性。只要修改本地时间，就能做到永不过期，所以这个字段现在已被 cache-control 取代。 cache-control 字段和 expires 同时出现的情况下，cache-control 优先级高 cache-control 的过期时间是由 max-age 来决定的，代表资源有效期是多少秒。另一个属性叫 s-maxage，表示资源在代理服务器上的有效期，两者同时出现则以 s-maxage 为准。cache-control 还有两个控制是否启用代理服务器缓存的属性。public 则代表资源既可被代理服务器缓存，也可被浏览器缓存，private 则只能被浏览器缓存。如果 cache-control 的值为 no-cache，则绕开浏览器，每次请求都会向服务器询问资源是否过期（走协商缓存路线），若值为 no-store，则资源不启用缓存（浏览器和代理服务器都是），每次请求都从服务器重新拿数据。 协商缓存协商缓存机制下，浏览器需要每次向服务器发送请求来询问资源相关信息，如果资源没有改动，则重定向回浏览器缓存，HTTP 状态码为 304，如下图： 协商缓存会在首次请求的响应头中返回 Last-Modified 字段，这个字段表示文件最后修改时间戳，随后浏览器每次请求都会在请求头中携带 If-Modified-Since 字段，这个字段值就是 Last-Modified 的值。服务器接收到 If-Modified-Since 字段，会去比对资源最后修改时间和字段值是否一致。不一致则重新返回资源，并在响应头中返回新的 Last-Modified 值，状态码是 200；一致则返回上图中的 304 状态码，且响应头中不返回新的 Last-Modified 字段。 Last-Modified 的弊端： 文件只是打开编辑，但是未修改任何内容，Last-Modified 的值也会更新，但文件内容是没有改变的 文件修改速度过快，比如 200ms 就修改完毕了，但是 If-Modified-Since 只能识别以秒为单位的时间戳，这就会导致资源已经修改，但是时间比对结果是一致的，不会重新返回新的资源 E-Tag 是服务器为每个资源生成的唯一的字符串标识符，只要文件内容不同，E-Tag 就不同，这就弥补了 Last-Modified 的弊端。如果 E-Tag 和 Last-Modified 同时出现，E-Tag 的优先级更高。如果启用 E-Tag，会在首次请求的响应头中返回最初的字符串标识符，浏览器在后面请求的请求头中携带 If-None-Match 字段，这个字符值就是 E-Tag 的值，若比对一致则返回 304 状态码，不一致则返回 200 状态码。 12ETag: W/&quot;2a3b-1602480f459&quot;If-None-Match: W/&quot;2a3b-1602480f459&quot; HTTP 缓存策略在业务中如何使用 HTTP 缓存可根据上图的流程来决定用什么缓存。资源是否需要服用，否则不启用缓存 cache-control 的值设为 no-store，是则判断是否每次都需要向服务器重新验证，是则 cache-control 的值设为 no-cache，否则判断是否需要启用代理服务器缓存，是则设置 cache-control 的值为 public，否则设置 cache-control 的值为 private。然后设置缓存的有效期和 E-Tag Memory Cache内存缓存是最快的，生命周期和 session 一样是会话级的。一般资源不会被放入内存缓存，只有 base64 大概率会被存入，还有体积小的文件有几率被存入内存缓存。 Service Worker CachePush Cache 浏览器只有在 Memory Cache、Service Worker Cache、HTTP Cache 都命中的情况下才会去询问 Push Cache Push Cache 的生命周期和 session 一样是会话级的 不同页面只要共享一个 HTTP2 连接，就能共享 Push Cache","link":"/2022/10/31/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"}],"tags":[{"name":"性能优化","slug":"性能优化","link":"/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"网络","slug":"网络","link":"/tags/%E7%BD%91%E7%BB%9C/"}],"categories":[{"name":"干货","slug":"干货","link":"/categories/%E5%B9%B2%E8%B4%A7/"}],"pages":[]}