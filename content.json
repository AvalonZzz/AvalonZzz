{"posts":[{"title":"hexo6.0-Icarus5.0打造私人博客指南","text":"前言网络上有很多关于 Hexo 搭建博客的详细教程，这里就不过多介绍。但是关于 Icarus 主题的配置大多都是老旧的，很多都是讲解 3.0 版本以下的 ejs 构建的 Icarus，3.0 以上用 jsx 构建的 Icarus 配置却很少提及，这里就将之前配置 Icarus5.1 版本趟过的坑分享出来，希望对想配置 Icarus 主题的小伙伴有点帮助。 修改 navbar 菜单语言 _config.icarus.yml中的navbar 的 menu 默认是英文的，我们可以将属性改为中文，便于更直观的查看菜单栏 修改网站 logo 和网页 favicon在_config.icarus.yml head 中的 favicon 属性可以配置网页 favicon，logo 属性可以修改网站 logo。 配置组件Icarus 主题集成了很多组件，我们可在 _config.icarus.yml中的widgets 下自定义自己所需要的配置。 这里我选择了 profile、toc、categories、archives 和 tags 组件，通过 position 属性的 left 或 right 来控制组件显示在左侧还是右侧。 最终效果图如下 post 页面的个性配置在文章的详情页面，我们可以将两侧的组件通过在根目录创建_config.post.yml配置文件来定制博文私有的组件。 这里我博客首页配置的是三栏布局，在文章详情页显示文章略显拥挤，导致文章显示的内容区域很少，在_config.post.yml文件中我们也可以将所有组件放置一侧，从而实现首页和文章详情页面不同的布局方式。 在_config.post.yml中按照上一节的配置方法可自由配置自己想要的组件。 文章页生成目录首先我们要在post页面的私有配置文件中配置目录组件，配置方法见上图中的toc配置项。 然后需要在文章的头部配置上toc: true 文章模板的配置上图已经展示了文档常用的配置项，这里详细说下各个配置项的作用 title：文章的标题，会在编译在html的head中 date：文章的创建日期 cover：文章的封面图 toc：是否生成文章的目录 tags：文章的标签，和keywords配置向互斥，如果不配置tags，则配置的keywords会生效并且生成在html中head的meta中，可如果配置了tags，则tags会取代keywords的内容出现在meta标签中，目前两者无法做到合并 categories：文章分类 excerpt：文章的descriptions描述，会descriptions的方式编译到html的head中。配置了这一项，则会将这项配置的值作为文章列表页的摘要 那么如何配置页面的模板呢？在根目录中有一个叫scaffolds的文件夹，里面有3个配置文章，分别指代hexo的3种页面，这里我配置的是post.md，其他2个配置方法一样。 生成列表页阅读更多安装hexo-excerpt插件，npm i hexo-excerpt --save 然后在 _config.icarus.yml中配置如下参数 然后我们就可以看到列表页的每篇文章底部就生成了阅读更多按钮 引入disqus评论Icarus集成了多种评论，这里我选取了disqus 首先，我们需要取disqus的官网去注册一个账号，然后通过首页右上角的admin按钮进入配置页面，点击Installing Disqus去创建一个站点，按照disqus的步骤配置完成之后会拿到一个唯一的short_name，通常short_name是你配置的用户名加上-disqus-com，我们只需要将拿到的short_name配置到_config.icarus.yml的comment属性中即可完成评论的接入。 接入看板娘网上很多看板娘教程都是老旧的，按照这些方式引入都不生效。 我们找到node_modules/hexo-theme-icarus/layout/layout.jsx，只需要将&lt;script src=&quot;https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js&quot;&gt;&lt;/script&gt;这段代码放入到html中即可引入看板娘 []: https://github.com/stevenjoezhang/live2d-widget “看板娘git仓库” 结尾以上就是我配置Icarus5.0以上版本主题是遇到的坑，如有问题，请在下方评论区留言。","link":"/2022/11/03/hexo6.0-Icarus5.1%E6%89%93%E9%80%A0%E7%A7%81%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%8C%87%E5%8D%97/"},{"title":"DOM必知必会","text":"节点层次Node 类型共有 12 种 Node 类型，可通过节点的nodeType属性访问，值为以下常量： Node.ELEMENT_NODE Node.ATTRBUTE_NODE Node.TEXT_NODE Node.CDATA_SECTION_NODE Node.ENTITY_REFERENCE_NODE Node.ENTITY_NODE Node.PROCESSING_INSTRUCTION_NODE Node.COMMENT_NODE Node.DOCUMENT_NODE Node.DOCUMENT_TYPE_NODE Node.DOCUMENT_FRAGMENT_NODE Node.NOTATION_NODE 123if (someNode.nodeType == Node.ELEMENT_NODE) { alert(&quot;Node is an element.&quot;);} nodeName 和 nodeValuenodeName 保存着节点的名字，对元素而言，nodeName 就是标签名，nodeValue 始终为 null 123if (someNode.nodeType === 1) { value = someNode.nodeName; // 显示元素的标签名} 节点关系每个节点都有 childNodes 属性，包含一个 NodeList 实例，可通过[]或 item()来获取 NodeList 中的项。DOM 结构变化会在 NodeList 中反映出来，NodeList 是实时的活动对象，而不是第一次访问时所获取内容的快照 每个节点都有 parentNode 属性，指向其 DOM 树中的父元素。childNodes 中每个节点都是同一列表中其他节点的同胞节点，可通过 previousSibling 和 nextSibling 来访问，列表中第一个节点的 previousSibling 和最后一个节点的 nextSibling 为 nullfirstChild 即childNodes[0];lastChild 即childNodes[childNodes.length - 1] hasChildNodes()方法用来检查节点是否有子节点，若结果为 true 则表示有一个或多个子节点 ownerDocument属性是一个指向代表整个文档的文档节点的指针 操纵节点以下 4 个方法都是通过 parentNode 操纵子节点 appendChild(node)用于在 childNodes 列表末尾添加节点，返回值为新添加的节点的引用，如果传入的 node 在文档中已存在，则将该 node 移动到最后一个位置 insertBefore(要插入的节点，参照节点)，调用后要插入的节点变成参照节点的前一个同胞节点并返回。如果参照节点是 null，则效果和 appendChild 一样 replaceChild(要插入的节点，要替换的节点) removeChild(要删除的节点),返回被移除的节点 其他方法所有节点类型还共享了以下方法: cloneNode(布尔值)会返回调用此方法的节点一模一样的节点，参数传入 true 表示深复制（即复制节点及其整个子 DOM 树），传入 false 只返回调用方法的节点。此时没有父节点，可用上面的操作方法插入到文档中 normalize()处理文档子树中的文本节点。如果发现空文本节点则将其删除；如果两个同胞节点是相邻的则将其合并为一个文本节点。 Document 类型Document 节点是文档的根节点，document 对象是 window 的属性，表示整个文档。 Document 节点的特征： Document 节点的 nodeType 是 9 Document 节点的 nodeName 是#document Document 节点的 nodeValue 是 null 文档子节点document 对象提供了以下几个访问子节点的快捷方式 document.documentElement：指向 html 元素的引用 document.body：指向 body 元素的引用 document.docType：指向文档类型元素的引用 文档信息document.title：文档标题，修改后会反映到页面标题上以下三个属性只有 domain 能设置document.URL：当前页面完整链接document.domain：当前页面的域名（如果 URL 有子域名则 domain 不能设设置 URL 没有的内容）document.referer：包含链接到当前页面的 URL 定位元素document.getElementById(id值)找到返回元素引用，没找到返回 nulldocument.getElementsByTagName(tagName)返回零或多个元素组成的 HTMLCollectiondocument.getElementsByName(name值)返回具有给定 name 属性的所有元素，是 NodeList HTMLCollection 和 NodeList 相似，是一个动态集合，可用[]或 item()来获取某一项。HTMLCollection 特定方法 namedItem(name 值)：通过给定 name 值从 HTMLCollection 中返回具有相同 name 属性的元素 特殊集合 document.anchors：包含文档中所有具有 name 属性的 a 标签 document.forms：包含文档中所有 form 元素 document.images：包含文档中所有 img 元素 document.links：包含文档中所有带 href 属性的 a 标签 Element 类型Element 类型特征： nodeType 为 1 nodeName 是标签名 nodeValue 值是 null nodeName 或者 tagName 属性用来获取元素的标签名，两者是一致的（大写） 123let div = document.getElementById(&quot;myDiv&quot;);alert(div.tagName); // &quot;DIV&quot;alert(div.tagName == div.nodeName); // true HTML 元素公共属性HTML 元素都具有以下属性： id：唯一标识符 title：元素的提示信息 lang：元素内容的语言 dir：语言的书写方向（ltr 左到右，rtl 右到左） className：元素的 class 属性 获取属性getAttribute(属性名)：获取给定属性的值 注意： 传给 getAttribute()的属性名和它们实际的属性名是一样的 getAttribute()也能获取自定义属性，自定义属性用data-作为前缀 通过 DOM 对象访问的属性和通过getAttribute()取值的不同： 在获取 style 属性时，通过元素的 style 属性获取到的时 CSSStyleDeclaration 对象，通过 getAttribute()访问到的时 css 字符串 在获取事件处理程序时，通过元素的 style 属性获取到的时一个 JS 函数，通过 getAttribute()获取到的时字符串形式的源代码 建议：在开发中，获取属性只使用对象属性，getAttribute 只用来获取自定义属性 设置属性setAttribute(要设置的属性名，属性的值)：以指定的值替换原来的值，如果属性不存在，则以指定的值创建该属性。 对象属性的方式可设置元素指定，但不能设置自定义属性，只能用 setAttribute()设置自定义属性 12div.mycolor = &quot;red&quot;;console.log(div.getAttribute(&quot;mycolor&quot;)); // null，因为对象属性设置了DOM属性不会自动变为元素属性 removeAttribute(要删除的属性)：将属性从元素中删除，不单单是删除属性值 attributes 属性attributes 属性包含一个 NamedNodeMap 实例，是一个类似 NodeList 的实时集合。元素每一个属性都表示为一个 Attr 节点保存在这个 NamedNodeMap 实例中。NamedNodeMap 对象包含以下方法： getNamedItem(name)：返回 nodeName 属性等于 name 的节点 removeNamedItem(name)：删除 nodeName 属性等于 name 的节点 setNamedItem(node)：向列表中添加 node 节点，以其 nodeName 为索引 item(pos)：返回索引位置 pos 处的节点 123console.log(box.attributes.getNamedItem(&quot;id&quot;)); // id='box'box.attributes.removeNamedItem(&quot;class&quot;);box.attributes.setNamedItem(newAttr); 创建元素document.createElement(标签名)创建元素，同时将其 ownerDocument 属性设为 document。 1let div = document.createElement(&quot;div&quot;); 元素后代元素通过 childNodes 属性获取元素所有的子节点（包括文本、注释等节点） 12345&lt;ul id=&quot;myList&quot;&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt;&lt;/ul&gt; 解析以上代码，ul 元素会包含 3 个 li 元素节点，4 个表示空格的 Text 节点。 所以操作通过 childNodes 获取到的子节点时，要先检查下 nodeType 属性 12345for (let i = 0, len = element.childNodes; i &lt; len; ++i) { if (element.childNodes[i].nodeType === 1) { // 执行某个操作 }}","link":"/2022/11/07/DOM%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/10/31/hello-world/"},{"title":"JavaScript 缓冲区入门","text":"ArrayBufferArrayBuffer 是一种预分配内存，不能直接操作它的内容，是所有 定型数组 和 DataView 的基本单位（即其他 定型数组 和 view 都是通过 ArrayBuffer 实例创建的）。ArrayBuffer(字节数)构造函数用于在内存中分配指定数量的空间byteLength 属性返回 ArrayBuffer 的字节数大小 12const buf = new ArrayBuffer(16);console.log(buf.byteLength); // 16 ArrayBuffer 实例一旦创建就不能再调整大小了，只能通过slice()复制部分或全部到新的实例中 123const buf = new ArrayBuffer(16);const buf1 = buf.slice(4, 12);console.log(buf1.byteLength); // 8 DataViewDataView 必须在已有 ArrayBuffer 的实例上才能创建 DataView 实例。这个实例使用全部或部分 ArrayBuffer，维护该 ArrayBuffer 实例的引用和 DataView 在 ArrayBuffer 中的开始位置。创建 DataView 实例：new DataView(ArrayBuffer, byteOffset, byteLength)byteOffset 值默认是 0，没有 byteLength 则读取到 ArrayBuffer 结尾。 属性： byteOffset 属性返回 DataView 的在 ArrayBuffer 实例中的偏移值 byteLength 属性和 ArrayBuffer 的一样，返回 DataView 实例的字节数大小 buffer 属性返回参数 ArrayBuffer 的引用 12345const buf = new ArrayBuffer(16);const dataView = new DataView(buf, 4, 8);console.log(dataView.byteOffset); // 4console.log(dataView.byteLength); // 8console.log(dataView.buffer === buf); // true 要通过 DataView 读取缓冲，还需要以下几个条件： 要读或写的字节偏移量 DataView 要使用某种 ElementType 来实现 JavaScript 的 Number 类型到缓冲内二进制格式的转换 内存中的字节序，默认是大端字节序 DataView 对缓冲中的数据类型没有任何预设，所以必须为缓冲中的数据指定 ElementType。ElementType 见下表： ElementType 字节 说明 等价 C 类型 值的范围 Int8 1 8 位有符号整数 signed char -128~127 Uint8 1 8 位无符号整数 unsigned char 0~255 Int16 2 16 位有符号整数 short -32768~32767 Uint16 2 16 位无符号整数 unsigned short 0~65535 Int32 4 32 位有符号整数 int -2147483628~2147483647 Uint32 4 32 位无符号整数 unsigned int 0~4294967295 Float32 4 32 位 IEEE-754 浮点数 float -3.4e+38~+3.4e+38 Float64 8 64 位 IEEE-754 浮点数 double -1.7e+308~+1.7e+308 DataView 为所有 ElementType 都暴露了 get 和 set 方法，这些方法使用 byteOffset 定位要读取或写入值的位置。 123456const buf = new ArrayBuffer(2);const view = new DataView(buf);console.log(view.getInt8(0)); // 0console.log(view.getInt8(1)); // 0console.log(view.setUint8(1, 255));console.log(view.getUint8(1)); // 255 DataView 的所有 API 都以大端字节序为默认值，如果最后一个参数传 true 则启用小端字节序DataView 完成读写操作的前提时有充足的缓冲区，否则会抛出 RangeError。DataView 在写入缓冲里会尽可能把一个值转为适当的类型，后备为 0。如果无法转换则抛出错误。 定型数组定型数组是另一种形式的 ArrayBuffer 视图，特定于一种 ElementType 且遵循系统原生的字节序。 创建定型数组的方式： 读取已有缓冲 使用自有缓冲 填充可迭代结构 填充基于任意类型的定型数组 &lt;ElementType&gt;.from() &lt;ElementType&gt;.of() 定型数组实例的属性： length：定型数组的长度（不是字节长度） buffer：定型数组引用的 ArrayBuffer 实例 12345678910111213141516171819202122232425262728293031323334353637const buf = new ArrayBuffer(12);// 读取已有缓冲的方式创建定型数组const ints = new Int32Array(buf);// 这个定型数组知道自己的每个元素需要4字节，所以长度为3console.log(ints.length); // 3// 使用自有缓冲的方式创建定型数组const ints2 = new Int32Array(6);// 每个数值使用4字节，因此ArrayBuffer是24字节console.log(ints2.length); // 6// 类似DataView，定性数组也有一个指向关联缓冲的引用console.log(ints2.buffer.byteLength); // 24// 使用填充可迭代结构的方式创建定型数组const ints3 = new Int32Array([2, 4, 6, 8]);console.log(ints3.length); // 4console.log(ints3.buffer.byteLength); // 16console.log(ints3[2]); // 6// 使用填充其他任意类型的定型数组的方式创建定型数组const ints4 = new Int16Array(ints3);// 新类型数组会分配自己的缓冲，对应索引的每个值会相应地转换为新格式console.log(ints4.length); // 4console.log(ints4.buffer.byteLength); // 8console.log(ints4[2]); // 6// 使用&lt;ElementType&gt;.from()的方式创建定型数组const ints5 = Int16Array.from([3, 5, 7, 9]);console.log(ints5.length); // 4console.log(ints5.buffer.byteLength); // 8console.log(ints5[2]); // 7// 使用&lt;ElementType&gt;.of()地方式创建定型数组const floats = Float32Array.of(3.14, 2.718, 1.618);console.log(floats.length); // 3console.log(floats.buffer.byteLength); // 12console.log(floats[2]); // 1.618 定型数组的构造函数和实例都有一个BYTES_PER_ELEMENT属性，返回该类型数组每个元素的字节数 12345console.log(Int16Array.BYTES_PER_ELEMENT); // 16const ints = new Int32Array(1);const floats = new FLoat64Array(1);console.log(ints.BYTES_PER_ELEMENT); // 4console.log(floats.BYTES_PER_ELEMENT); // 8 定型数组支持所有数组方法，包括 for…of 和扩展运算符，除了会改变原数组长度的 concat、pop、push、shift、unshift、splice 这 6 个方法 定型数组提供了两个新方法，可以快速向外或向内复制数据：set()和 subarray() set()从提供的数组或定型数组中把值复制到当前定型数组中指定的索引位置，溢出抛出错误 123456const container = new Int16Array(8);container.set(Int32Array.of(1, 2, 3, 4));console.log(container); // [1,2,3,4,0,0,0,0]container.set([5, 6, 7, 8], 4);console.log(container); // [1,2,3,4,5,6,7,8]container.set([5, 6, 7, 8], 7); // RangeError: offset is out of bounds subarray()从原始定型数组中复制值，返回一个新的定型数组。复制值的开始索引和结束索引是可选的。 12345678910const source = Int16Array.of(2, 4, 6, 8);// subarray不传开始索引和结束索引就是复制完整的定型数组const fullCopy = source.subarray();console.log(fullCopy); // [2,4,6,8]// 只输入开始索引即从开始索引到结束const halfCopy = source.subarray(2);console.log(halfCopy); // [6,8]const partialCopy = source.subarray(1, 3);console.log(partialCopy); // [4, 6] 定型数组中值的下溢和上溢不会影响到其他索引 1234567const ints = new Int8Array(2);const unsignedInts = new Uint8Array(2);unsignedInts[1] = 256;console.log(unsignedInts[1]); // [0,0] 只会取最低有效位上的8位unsignedInts[1] = 511;console.log(unsignedInts[1]); // [0,255]","link":"/2022/11/02/%E7%BC%93%E5%86%B2%E5%8C%BA/"},{"title":"缓存机制","text":"缓存分类浏览器缓存大致上分为四类，按以下优先级顺序排列： Memery Cache Service Worker Cache HTTP Cache Push Cache HTTP CacheHTTP Cache 分为强缓存和协商缓存，强缓存优先级高，只有在强缓存未命中的情况下才会走协商缓存。 强缓存强缓存通过 expires 和 cache-control 字段来控制，如果强缓存命中则直接从缓存中取数据，不再发起服务器请求。强缓存命中的 HTTP 状态码是 200，如下图： 强缓存以前使用 expires 字段来控制，这是一个时间戳，通过比对本地时间来判断资源是否过期，极度依赖本地时间的准确性。只要修改本地时间，就能做到永不过期，所以这个字段现在已被 cache-control 取代。 cache-control 字段和 expires 同时出现的情况下，cache-control 优先级高 cache-control 的过期时间是由 max-age 来决定的，代表资源有效期是多少秒。另一个属性叫 s-maxage，表示资源在代理服务器上的有效期，两者同时出现则以 s-maxage 为准。cache-control 还有两个控制是否启用代理服务器缓存的属性。public 则代表资源既可被代理服务器缓存，也可被浏览器缓存，private 则只能被浏览器缓存。如果 cache-control 的值为 no-cache，则绕开浏览器，每次请求都会向服务器询问资源是否过期（走协商缓存路线），若值为 no-store，则资源不启用缓存（浏览器和代理服务器都是），每次请求都从服务器重新拿数据。 协商缓存协商缓存机制下，浏览器需要每次向服务器发送请求来询问资源相关信息，如果资源没有改动，则重定向回浏览器缓存，HTTP 状态码为 304，如下图： 协商缓存会在首次请求的响应头中返回 Last-Modified 字段，这个字段表示文件最后修改时间戳，随后浏览器每次请求都会在请求头中携带 If-Modified-Since 字段，这个字段值就是 Last-Modified 的值。服务器接收到 If-Modified-Since 字段，会去比对资源最后修改时间和字段值是否一致。不一致则重新返回资源，并在响应头中返回新的 Last-Modified 值，状态码是 200；一致则返回上图中的 304 状态码，且响应头中不返回新的 Last-Modified 字段。 Last-Modified 的弊端： 文件只是打开编辑，但是未修改任何内容，Last-Modified 的值也会更新，但文件内容是没有改变的 文件修改速度过快，比如 200ms 就修改完毕了，但是 If-Modified-Since 只能识别以秒为单位的时间戳，这就会导致资源已经修改，但是时间比对结果是一致的，不会重新返回新的资源 E-Tag 是服务器为每个资源生成的唯一的字符串标识符，只要文件内容不同，E-Tag 就不同，这就弥补了 Last-Modified 的弊端。如果 E-Tag 和 Last-Modified 同时出现，E-Tag 的优先级更高。如果启用 E-Tag，会在首次请求的响应头中返回最初的字符串标识符，浏览器在后面请求的请求头中携带 If-None-Match 字段，这个字符值就是 E-Tag 的值，若比对一致则返回 304 状态码，不一致则返回 200 状态码。 12ETag: W/&quot;2a3b-1602480f459&quot;If-None-Match: W/&quot;2a3b-1602480f459&quot; HTTP 缓存策略在业务中如何使用 HTTP 缓存可根据上图的流程来决定用什么缓存。资源是否需要服用，否则不启用缓存 cache-control 的值设为 no-store，是则判断是否每次都需要向服务器重新验证，是则 cache-control 的值设为 no-cache，否则判断是否需要启用代理服务器缓存，是则设置 cache-control 的值为 public，否则设置 cache-control 的值为 private。然后设置缓存的有效期和 E-Tag Memory Cache内存缓存是最快的，生命周期和 session 一样是会话级的。一般资源不会被放入内存缓存，只有 base64 大概率会被存入，还有体积小的文件有几率被存入内存缓存。 Service Worker CachePush Cache 浏览器只有在 Memory Cache、Service Worker Cache、HTTP Cache 都命中的情况下才会去询问 Push Cache Push Cache 的生命周期和 session 一样是会话级的 不同页面只要共享一个 HTTP2 连接，就能共享 Push Cache","link":"/2022/11/01/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"}],"tags":[{"name":"Hexo+Icarus","slug":"Hexo-Icarus","link":"/tags/Hexo-Icarus/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"性能优化","slug":"性能优化","link":"/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"浏览器","slug":"浏览器","link":"/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"缓存","slug":"缓存","link":"/tags/%E7%BC%93%E5%AD%98/"},{"name":"网络","slug":"网络","link":"/tags/%E7%BD%91%E7%BB%9C/"}],"categories":[{"name":"干货","slug":"干货","link":"/categories/%E5%B9%B2%E8%B4%A7/"},{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"pages":[]}