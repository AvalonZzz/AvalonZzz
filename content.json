{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/10/31/hello-world/"},{"title":"JavaScript 缓冲区入门","text":"JavaScript 缓冲区入门ArrayBufferArrayBuffer 是一种预分配内存，不能直接操作它的内容，是所有 定型数组 和 DataView 的基本单位（即其他 定型数组 和 view 都是通过 ArrayBuffer 实例创建的）。ArrayBuffer(字节数)构造函数用于在内存中分配指定数量的空间byteLength 属性返回 ArrayBuffer 的字节数大小 12const buf = new ArrayBuffer(16);console.log(buf.byteLength); // 16 ArrayBuffer 实例一旦创建就不能再调整大小了，只能通过slice()复制部分或全部到新的实例中 123const buf = new ArrayBuffer(16);const buf1 = buf.slice(4, 12);console.log(buf1.byteLength); // 8 DataViewDataView 必须在已有 ArrayBuffer 的实例上才能创建 DataView 实例。这个实例使用全部或部分 ArrayBuffer，维护该 ArrayBuffer 实例的引用和 DataView 在 ArrayBuffer 中的开始位置。创建 DataView 实例：new DataView(ArrayBuffer, byteOffset, byteLength)byteOffset 值默认是 0，没有 byteLength 则读取到 ArrayBuffer 结尾。 属性： byteOffset 属性返回 DataView 的在 ArrayBuffer 实例中的偏移值 byteLength 属性和 ArrayBuffer 的一样，返回 DataView 实例的字节数大小 buffer 属性返回参数 ArrayBuffer 的引用 12345const buf = new ArrayBuffer(16);const dataView = new DataView(buf, 4, 8);console.log(dataView.byteOffset); // 4console.log(dataView.byteLength); // 8console.log(dataView.buffer === buf); // true 要通过 DataView 读取缓冲，还需要以下几个条件： 要读或写的字节偏移量 DataView 要使用某种 ElementType 来实现 JavaScript 的 Number 类型到缓冲内二进制格式的转换 内存中的字节序，默认是大端字节序 DataView 对缓冲中的数据类型没有任何预设，所以必须为缓冲中的数据指定 ElementType。ElementType 见下表： ElementType 字节 说明 等价 C 类型 值的范围 Int8 1 8 位有符号整数 signed char -128~127 Uint8 1 8 位无符号整数 unsigned char 0~255 Int16 2 16 位有符号整数 short -32768~32767 Uint16 2 16 位无符号整数 unsigned short 0~65535 Int32 4 32 位有符号整数 int -2147483628~2147483647 Uint32 4 32 位无符号整数 unsigned int 0~4294967295 Float32 4 32 位 IEEE-754 浮点数 float -3.4e+38~+3.4e+38 Float64 8 64 位 IEEE-754 浮点数 double -1.7e+308~+1.7e+308 DataView 为所有 ElementType 都暴露了 get 和 set 方法，这些方法使用 byteOffset 定位要读取或写入值的位置。 123456const buf = new ArrayBuffer(2);const view = new DataView(buf);console.log(view.getInt8(0)); // 0console.log(view.getInt8(1)); // 0console.log(view.setUint8(1, 255));console.log(view.getUint8(1)); // 255 DataView 的所有 API 都以大端字节序为默认值，如果最后一个参数传 true 则启用小端字节序DataView 完成读写操作的前提时有充足的缓冲区，否则会抛出 RangeError。DataView 在写入缓冲里会尽可能把一个值转为适当的类型，后备为 0。如果无法转换则抛出错误。 定型数组定型数组是另一种形式的 ArrayBuffer 视图，特定于一种 ElementType 且遵循系统原生的字节序。 创建定型数组的方式： 读取已有缓冲 使用自有缓冲 填充可迭代结构 填充基于任意类型的定型数组 &lt;ElementType&gt;.from() &lt;ElementType&gt;.of() 定型数组实例的属性： length：定型数组的长度（不是字节长度） buffer：定型数组引用的 ArrayBuffer 实例 12345678910111213141516171819202122232425262728293031323334353637const buf = new ArrayBuffer(12);// 读取已有缓冲的方式创建定型数组const ints = new Int32Array(buf);// 这个定型数组知道自己的每个元素需要4字节，所以长度为3console.log(ints.length); // 3// 使用自有缓冲的方式创建定型数组const ints2 = new Int32Array(6);// 每个数值使用4字节，因此ArrayBuffer是24字节console.log(ints2.length); // 6// 类似DataView，定性数组也有一个指向关联缓冲的引用console.log(ints2.buffer.byteLength); // 24// 使用填充可迭代结构的方式创建定型数组const ints3 = new Int32Array([2, 4, 6, 8]);console.log(ints3.length); // 4console.log(ints3.buffer.byteLength); // 16console.log(ints3[2]); // 6// 使用填充其他任意类型的定型数组的方式创建定型数组const ints4 = new Int16Array(ints3);// 新类型数组会分配自己的缓冲，对应索引的每个值会相应地转换为新格式console.log(ints4.length); // 4console.log(ints4.buffer.byteLength); // 8console.log(ints4[2]); // 6// 使用&lt;ElementType&gt;.from()的方式创建定型数组const ints5 = Int16Array.from([3, 5, 7, 9]);console.log(ints5.length); // 4console.log(ints5.buffer.byteLength); // 8console.log(ints5[2]); // 7// 使用&lt;ElementType&gt;.of()地方式创建定型数组const floats = Float32Array.of(3.14, 2.718, 1.618);console.log(floats.length); // 3console.log(floats.buffer.byteLength); // 12console.log(floats[2]); // 1.618 定型数组的构造函数和实例都有一个BYTES_PER_ELEMENT属性，返回该类型数组每个元素的字节数 12345console.log(Int16Array.BYTES_PER_ELEMENT); // 16const ints = new Int32Array(1);const floats = new FLoat64Array(1);console.log(ints.BYTES_PER_ELEMENT); // 4console.log(floats.BYTES_PER_ELEMENT); // 8 定型数组支持所有数组方法，包括 for…of 和扩展运算符，除了会改变原数组长度的 concat、pop、push、shift、unshift、splice 这 6 个方法 定型数组提供了两个新方法，可以快速向外或向内复制数据：set()和 subarray() set()从提供的数组或定型数组中把值复制到当前定型数组中指定的索引位置，溢出抛出错误 123456const container = new Int16Array(8);container.set(Int32Array.of(1, 2, 3, 4));console.log(container); // [1,2,3,4,0,0,0,0]container.set([5, 6, 7, 8], 4);console.log(container); // [1,2,3,4,5,6,7,8]container.set([5, 6, 7, 8], 7); // RangeError: offset is out of bounds subarray()从原始定型数组中复制值，返回一个新的定型数组。复制值的开始索引和结束索引是可选的。 12345678910const source = Int16Array.of(2, 4, 6, 8);// subarray不传开始索引和结束索引就是复制完整的定型数组const fullCopy = source.subarray();console.log(fullCopy); // [2,4,6,8]// 只输入开始索引即从开始索引到结束const halfCopy = source.subarray(2);console.log(halfCopy); // [6,8]const partialCopy = source.subarray(1, 3);console.log(partialCopy); // [4, 6] 定型数组中值的下溢和上溢不会影响到其他索引 1234567const ints = new Int8Array(2);const unsignedInts = new Uint8Array(2);unsignedInts[1] = 256;console.log(unsignedInts[1]); // [0,0] 只会取最低有效位上的8位unsignedInts[1] = 511;console.log(unsignedInts[1]); // [0,255]","link":"/2022/11/02/%E7%BC%93%E5%86%B2%E5%8C%BA/"},{"title":"缓存机制","text":"缓存分类浏览器缓存大致上分为四类，按以下优先级顺序排列： Memery Cache Service Worker Cache HTTP Cache Push Cache HTTP CacheHTTP Cache 分为强缓存和协商缓存，强缓存优先级高，只有在强缓存未命中的情况下才会走协商缓存。 强缓存强缓存通过 expires 和 cache-control 字段来控制，如果强缓存命中则直接从缓存中取数据，不再发起服务器请求。强缓存命中的 HTTP 状态码是 200，如下图： 强缓存以前使用 expires 字段来控制，这是一个时间戳，通过比对本地时间来判断资源是否过期，极度依赖本地时间的准确性。只要修改本地时间，就能做到永不过期，所以这个字段现在已被 cache-control 取代。 cache-control 字段和 expires 同时出现的情况下，cache-control 优先级高 cache-control 的过期时间是由 max-age 来决定的，代表资源有效期是多少秒。另一个属性叫 s-maxage，表示资源在代理服务器上的有效期，两者同时出现则以 s-maxage 为准。cache-control 还有两个控制是否启用代理服务器缓存的属性。public 则代表资源既可被代理服务器缓存，也可被浏览器缓存，private 则只能被浏览器缓存。如果 cache-control 的值为 no-cache，则绕开浏览器，每次请求都会向服务器询问资源是否过期（走协商缓存路线），若值为 no-store，则资源不启用缓存（浏览器和代理服务器都是），每次请求都从服务器重新拿数据。 协商缓存协商缓存机制下，浏览器需要每次向服务器发送请求来询问资源相关信息，如果资源没有改动，则重定向回浏览器缓存，HTTP 状态码为 304，如下图： 协商缓存会在首次请求的响应头中返回 Last-Modified 字段，这个字段表示文件最后修改时间戳，随后浏览器每次请求都会在请求头中携带 If-Modified-Since 字段，这个字段值就是 Last-Modified 的值。服务器接收到 If-Modified-Since 字段，会去比对资源最后修改时间和字段值是否一致。不一致则重新返回资源，并在响应头中返回新的 Last-Modified 值，状态码是 200；一致则返回上图中的 304 状态码，且响应头中不返回新的 Last-Modified 字段。 Last-Modified 的弊端： 文件只是打开编辑，但是未修改任何内容，Last-Modified 的值也会更新，但文件内容是没有改变的 文件修改速度过快，比如 200ms 就修改完毕了，但是 If-Modified-Since 只能识别以秒为单位的时间戳，这就会导致资源已经修改，但是时间比对结果是一致的，不会重新返回新的资源 E-Tag 是服务器为每个资源生成的唯一的字符串标识符，只要文件内容不同，E-Tag 就不同，这就弥补了 Last-Modified 的弊端。如果 E-Tag 和 Last-Modified 同时出现，E-Tag 的优先级更高。如果启用 E-Tag，会在首次请求的响应头中返回最初的字符串标识符，浏览器在后面请求的请求头中携带 If-None-Match 字段，这个字符值就是 E-Tag 的值，若比对一致则返回 304 状态码，不一致则返回 200 状态码。 12ETag: W/&quot;2a3b-1602480f459&quot;If-None-Match: W/&quot;2a3b-1602480f459&quot; HTTP 缓存策略在业务中如何使用 HTTP 缓存可根据上图的流程来决定用什么缓存。资源是否需要服用，否则不启用缓存 cache-control 的值设为 no-store，是则判断是否每次都需要向服务器重新验证，是则 cache-control 的值设为 no-cache，否则判断是否需要启用代理服务器缓存，是则设置 cache-control 的值为 public，否则设置 cache-control 的值为 private。然后设置缓存的有效期和 E-Tag Memory Cache内存缓存是最快的，生命周期和 session 一样是会话级的。一般资源不会被放入内存缓存，只有 base64 大概率会被存入，还有体积小的文件有几率被存入内存缓存。 Service Worker CachePush Cache 浏览器只有在 Memory Cache、Service Worker Cache、HTTP Cache 都命中的情况下才会去询问 Push Cache Push Cache 的生命周期和 session 一样是会话级的 不同页面只要共享一个 HTTP2 连接，就能共享 Push Cache","link":"/2022/11/01/%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"性能优化","slug":"性能优化","link":"/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"浏览器","slug":"浏览器","link":"/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"缓存","slug":"缓存","link":"/tags/%E7%BC%93%E5%AD%98/"},{"name":"网络","slug":"网络","link":"/tags/%E7%BD%91%E7%BB%9C/"}],"categories":[{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"干货","slug":"干货","link":"/categories/%E5%B9%B2%E8%B4%A7/"}],"pages":[]}